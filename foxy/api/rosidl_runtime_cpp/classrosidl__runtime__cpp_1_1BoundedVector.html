<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rosidl_runtime_cpp: rosidl_runtime_cpp::BoundedVector&lt; _Tp, _UpperBound, _Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rosidl_runtime_cpp
   &#160;<span id="projectnumber">master</span>
   </div>
   <div id="projectbrief">Generate the rosidl interfaces in C++.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerosidl__runtime__cpp.html">rosidl_runtime_cpp</a></li><li class="navelem"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classrosidl__runtime__cpp_1_1BoundedVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rosidl_runtime_cpp::BoundedVector&lt; _Tp, _UpperBound, _Alloc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A container based on <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> but with an upper bound.  
 <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="bounded__vector_8hpp_source.html">bounded_vector.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rosidl_runtime_cpp::BoundedVector&lt; _Tp, _UpperBound, _Alloc &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classrosidl__runtime__cpp_1_1BoundedVector__inherit__graph.png" border="0" usemap="#rosidl__runtime__cpp_1_1BoundedVector_3_01__Tp_00_01__UpperBound_00_01__Alloc_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="rosidl__runtime__cpp_1_1BoundedVector_3_01__Tp_00_01__UpperBound_00_01__Alloc_01_4_inherit__map" id="rosidl__runtime__cpp_1_1BoundedVector_3_01__Tp_00_01__UpperBound_00_01__Alloc_01_4_inherit__map">
<area shape="rect" title="A container based on std::vector but with an upper bound." alt="" coords="5,95,180,151"/>
<area shape="rect" href="http://en.cppreference.com/w/cpp/container/vector.html" title=" " alt="" coords="14,5,171,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for rosidl_runtime_cpp::BoundedVector&lt; _Tp, _UpperBound, _Alloc &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classrosidl__runtime__cpp_1_1BoundedVector__coll__graph.png" border="0" usemap="#rosidl__runtime__cpp_1_1BoundedVector_3_01__Tp_00_01__UpperBound_00_01__Alloc_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="rosidl__runtime__cpp_1_1BoundedVector_3_01__Tp_00_01__UpperBound_00_01__Alloc_01_4_coll__map" id="rosidl__runtime__cpp_1_1BoundedVector_3_01__Tp_00_01__UpperBound_00_01__Alloc_01_4_coll__map">
<area shape="rect" title="A container based on std::vector but with an upper bound." alt="" coords="5,95,180,151"/>
<area shape="rect" href="http://en.cppreference.com/w/cpp/container/vector.html" title=" " alt="" coords="14,5,171,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9b67ad1735b252821d65f89d4c372f97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a9b67ad1735b252821d65f89d4c372f97">BoundedVector</a> () noexcept(<a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_default_constructible.html">std::is_nothrow_default_constructible</a>&lt; _Alloc &gt;::value)</td></tr>
<tr class="memdesc:a9b67ad1735b252821d65f89d4c372f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a BoundedVector with no elements.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a9b67ad1735b252821d65f89d4c372f97">More...</a><br /></td></tr>
<tr class="separator:a9b67ad1735b252821d65f89d4c372f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be47de071b773e16ee109babafed265"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a4be47de071b773e16ee109babafed265">BoundedVector</a> (const typename _Base::allocator_type &amp;__a) noexcept</td></tr>
<tr class="memdesc:a4be47de071b773e16ee109babafed265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a BoundedVector with no elements.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a4be47de071b773e16ee109babafed265">More...</a><br /></td></tr>
<tr class="separator:a4be47de071b773e16ee109babafed265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784bc45020945077a0f29b3fd66b330d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a784bc45020945077a0f29b3fd66b330d">BoundedVector</a> (typename _Base::size_type __n, const typename _Base::allocator_type &amp;__a=allocator_type())</td></tr>
<tr class="memdesc:a784bc45020945077a0f29b3fd66b330d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a BoundedVector with default constructed elements.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a784bc45020945077a0f29b3fd66b330d">More...</a><br /></td></tr>
<tr class="separator:a784bc45020945077a0f29b3fd66b330d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcbcc89a4e79e70bf937a526009c97c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#aebcbcc89a4e79e70bf937a526009c97c">BoundedVector</a> (typename _Base::size_type __n, const typename _Base::value_type &amp;__value, const typename _Base::allocator_type &amp;__a=allocator_type())</td></tr>
<tr class="memdesc:aebcbcc89a4e79e70bf937a526009c97c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a BoundedVector with copies of an exemplar element.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#aebcbcc89a4e79e70bf937a526009c97c">More...</a><br /></td></tr>
<tr class="separator:aebcbcc89a4e79e70bf937a526009c97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba011bc822a8c2f3bed700d7aba8bd1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#aba011bc822a8c2f3bed700d7aba8bd1d">BoundedVector</a> (const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;__x)</td></tr>
<tr class="memdesc:aba011bc822a8c2f3bed700d7aba8bd1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">BoundedVector copy constructor.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#aba011bc822a8c2f3bed700d7aba8bd1d">More...</a><br /></td></tr>
<tr class="separator:aba011bc822a8c2f3bed700d7aba8bd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759dc2faee77bdc3271e9ee591773cd0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a759dc2faee77bdc3271e9ee591773cd0">BoundedVector</a> (<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;&amp;__x) noexcept</td></tr>
<tr class="memdesc:a759dc2faee77bdc3271e9ee591773cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">BoundedVector move constructor.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a759dc2faee77bdc3271e9ee591773cd0">More...</a><br /></td></tr>
<tr class="separator:a759dc2faee77bdc3271e9ee591773cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34c1b3d2998a2f16004e03975dd506d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#ac34c1b3d2998a2f16004e03975dd506d">BoundedVector</a> (const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;__x, const typename _Base::allocator_type &amp;__a)</td></tr>
<tr class="memdesc:ac34c1b3d2998a2f16004e03975dd506d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor with alternative allocator.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#ac34c1b3d2998a2f16004e03975dd506d">More...</a><br /></td></tr>
<tr class="separator:ac34c1b3d2998a2f16004e03975dd506d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca3e7ac66889d3996809f0b416e05a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#adca3e7ac66889d3996809f0b416e05a1">BoundedVector</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; typename _Base::value_type &gt; __l, const typename _Base::allocator_type &amp;__a=typename _Base::allocator_type())</td></tr>
<tr class="memdesc:adca3e7ac66889d3996809f0b416e05a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a BoundedVector from an initializer list.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#adca3e7ac66889d3996809f0b416e05a1">More...</a><br /></td></tr>
<tr class="separator:adca3e7ac66889d3996809f0b416e05a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31cd9a81afab23406e52c168311c2d8"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:af31cd9a81afab23406e52c168311c2d8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#af31cd9a81afab23406e52c168311c2d8">BoundedVector</a> (_InputIterator __first, _InputIterator __last, const typename _Base::allocator_type &amp;__a=allocator_type())</td></tr>
<tr class="memdesc:af31cd9a81afab23406e52c168311c2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a BoundedVector from a range.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#af31cd9a81afab23406e52c168311c2d8">More...</a><br /></td></tr>
<tr class="separator:af31cd9a81afab23406e52c168311c2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dc3c168ebba1ebc13303ef42de3af0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a48dc3c168ebba1ebc13303ef42de3af0">~BoundedVector</a> () noexcept</td></tr>
<tr class="memdesc:a48dc3c168ebba1ebc13303ef42de3af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dtor only erases the elements.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a48dc3c168ebba1ebc13303ef42de3af0">More...</a><br /></td></tr>
<tr class="separator:a48dc3c168ebba1ebc13303ef42de3af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98049e1dc6a05b67825299042fad574b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a98049e1dc6a05b67825299042fad574b">operator=</a> (const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;__x)</td></tr>
<tr class="memdesc:a98049e1dc6a05b67825299042fad574b"><td class="mdescLeft">&#160;</td><td class="mdescRight">BoundedVector assignment operator.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a98049e1dc6a05b67825299042fad574b">More...</a><br /></td></tr>
<tr class="separator:a98049e1dc6a05b67825299042fad574b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf20ca748fc8deab90c8a9a3909752c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#afcf20ca748fc8deab90c8a9a3909752c">operator=</a> (<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;&amp;__x)</td></tr>
<tr class="memdesc:afcf20ca748fc8deab90c8a9a3909752c"><td class="mdescLeft">&#160;</td><td class="mdescRight">BoundedVector move assignment operator  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#afcf20ca748fc8deab90c8a9a3909752c">More...</a><br /></td></tr>
<tr class="separator:afcf20ca748fc8deab90c8a9a3909752c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bde3d73393fa3c772aa751c4fc0d295"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a6bde3d73393fa3c772aa751c4fc0d295">operator=</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; typename _Base::value_type &gt; __l)</td></tr>
<tr class="memdesc:a6bde3d73393fa3c772aa751c4fc0d295"><td class="mdescLeft">&#160;</td><td class="mdescRight">BoundedVector list assignment operator.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a6bde3d73393fa3c772aa751c4fc0d295">More...</a><br /></td></tr>
<tr class="separator:a6bde3d73393fa3c772aa751c4fc0d295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257767f64c94837e25c2bbd598e63965"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a257767f64c94837e25c2bbd598e63965">assign</a> (typename _Base::size_type __n, const typename _Base::value_type &amp;__val)</td></tr>
<tr class="memdesc:a257767f64c94837e25c2bbd598e63965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a given value to a BoundedVector.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a257767f64c94837e25c2bbd598e63965">More...</a><br /></td></tr>
<tr class="separator:a257767f64c94837e25c2bbd598e63965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba629d7e4559e6f4e14432c6520a597"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:a7ba629d7e4559e6f4e14432c6520a597"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a7ba629d7e4559e6f4e14432c6520a597">assign</a> (_InputIterator __first, _InputIterator __last)</td></tr>
<tr class="memdesc:a7ba629d7e4559e6f4e14432c6520a597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a range to a BoundedVector.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a7ba629d7e4559e6f4e14432c6520a597">More...</a><br /></td></tr>
<tr class="separator:a7ba629d7e4559e6f4e14432c6520a597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397c503fdf0733eb320d54719ca2094f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a397c503fdf0733eb320d54719ca2094f">assign</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; typename _Base::value_type &gt; __l)</td></tr>
<tr class="memdesc:a397c503fdf0733eb320d54719ca2094f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign an initializer list to a BoundedVector.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a397c503fdf0733eb320d54719ca2094f">More...</a><br /></td></tr>
<tr class="separator:a397c503fdf0733eb320d54719ca2094f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d31ed11b31f083236a5ccd35060a78"><td class="memItemLeft" align="right" valign="top">_Base::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a42d31ed11b31f083236a5ccd35060a78">max_size</a> () const noexcept</td></tr>
<tr class="separator:a42d31ed11b31f083236a5ccd35060a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b11bd88990945e988619ae4c946fd12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a8b11bd88990945e988619ae4c946fd12">resize</a> (typename _Base::size_type __new_size)</td></tr>
<tr class="memdesc:a8b11bd88990945e988619ae4c946fd12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the BoundedVector to the specified number of elements.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a8b11bd88990945e988619ae4c946fd12">More...</a><br /></td></tr>
<tr class="separator:a8b11bd88990945e988619ae4c946fd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1cec89de0cc428783817370c570052"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#afb1cec89de0cc428783817370c570052">resize</a> (typename _Base::size_type __new_size, const typename _Base::value_type &amp;__x)</td></tr>
<tr class="memdesc:afb1cec89de0cc428783817370c570052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the BoundedVector to the specified number of elements.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#afb1cec89de0cc428783817370c570052">More...</a><br /></td></tr>
<tr class="separator:afb1cec89de0cc428783817370c570052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedcdabf83ebd480bf5e407eac3b6b8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#afedcdabf83ebd480bf5e407eac3b6b8e">reserve</a> (typename _Base::size_type __n)</td></tr>
<tr class="memdesc:afedcdabf83ebd480bf5e407eac3b6b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to preallocate enough memory for specified number of elements.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#afedcdabf83ebd480bf5e407eac3b6b8e">More...</a><br /></td></tr>
<tr class="separator:afedcdabf83ebd480bf5e407eac3b6b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f40a782edaa41caed8d07dbd411999"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; !std::is_same&lt; T, _Tp &gt;::value &amp;&amp;!std::is_same&lt; T, bool &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a88f40a782edaa41caed8d07dbd411999"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a88f40a782edaa41caed8d07dbd411999">data</a> () noexcept</td></tr>
<tr class="memdesc:a88f40a782edaa41caed8d07dbd411999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer such that [<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a88f40a782edaa41caed8d07dbd411999" title="Return a pointer such that [data(), data() + size()) is a valid range.">data()</a>, <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a88f40a782edaa41caed8d07dbd411999" title="Return a pointer such that [data(), data() + size()) is a valid range.">data()</a> + <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/size.html">size()</a>) is a valid range.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a88f40a782edaa41caed8d07dbd411999">More...</a><br /></td></tr>
<tr class="separator:a88f40a782edaa41caed8d07dbd411999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6751d4a9bf8a3163d06185d5f25d01e8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; !std::is_same&lt; T, _Tp &gt;::value &amp;&amp;!std::is_same&lt; T, bool &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a6751d4a9bf8a3163d06185d5f25d01e8"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a6751d4a9bf8a3163d06185d5f25d01e8">data</a> () const noexcept</td></tr>
<tr class="separator:a6751d4a9bf8a3163d06185d5f25d01e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f804dbbbd70111c2e9d0e4cf5f4f1d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a6f804dbbbd70111c2e9d0e4cf5f4f1d2">push_back</a> (const typename _Base::value_type &amp;__x)</td></tr>
<tr class="memdesc:a6f804dbbbd70111c2e9d0e4cf5f4f1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add data to the end of the BoundedVector.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a6f804dbbbd70111c2e9d0e4cf5f4f1d2">More...</a><br /></td></tr>
<tr class="separator:a6f804dbbbd70111c2e9d0e4cf5f4f1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66251403754048dbc0eb5dc33a32b448"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a66251403754048dbc0eb5dc33a32b448">push_back</a> (typename _Base::value_type &amp;&amp;__x)</td></tr>
<tr class="separator:a66251403754048dbc0eb5dc33a32b448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e716dd4d1adbe8d7f5cc8d9bb67a36"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:ad6e716dd4d1adbe8d7f5cc8d9bb67a36"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#ad6e716dd4d1adbe8d7f5cc8d9bb67a36">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ad6e716dd4d1adbe8d7f5cc8d9bb67a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add data to the end of the BoundedVector.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#ad6e716dd4d1adbe8d7f5cc8d9bb67a36">More...</a><br /></td></tr>
<tr class="separator:ad6e716dd4d1adbe8d7f5cc8d9bb67a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e46aa51d1fa2950966bf362dc5d81d9"><td class="memTemplParams" colspan="2">template&lt;typename ... _Args&gt; </td></tr>
<tr class="memitem:a0e46aa51d1fa2950966bf362dc5d81d9"><td class="memTemplItemLeft" align="right" valign="top">_Base::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a0e46aa51d1fa2950966bf362dc5d81d9">emplace</a> (typename _Base::const_iterator __position, _Args &amp;&amp;... __args)</td></tr>
<tr class="memdesc:a0e46aa51d1fa2950966bf362dc5d81d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an object in BoundedVector before specified iterator.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a0e46aa51d1fa2950966bf362dc5d81d9">More...</a><br /></td></tr>
<tr class="separator:a0e46aa51d1fa2950966bf362dc5d81d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa245ce96b6f037bcef941586f6b1ce79"><td class="memItemLeft" align="right" valign="top">_Base::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#aa245ce96b6f037bcef941586f6b1ce79">insert</a> (typename _Base::const_iterator __position, const typename _Base::value_type &amp;__x)</td></tr>
<tr class="memdesc:aa245ce96b6f037bcef941586f6b1ce79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert given value into BoundedVector before specified iterator.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#aa245ce96b6f037bcef941586f6b1ce79">More...</a><br /></td></tr>
<tr class="separator:aa245ce96b6f037bcef941586f6b1ce79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1e2a9a9ed77690aaefa4682016477b"><td class="memItemLeft" align="right" valign="top">_Base::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#aba1e2a9a9ed77690aaefa4682016477b">insert</a> (typename _Base::const_iterator __position, typename _Base::value_type &amp;&amp;__x)</td></tr>
<tr class="memdesc:aba1e2a9a9ed77690aaefa4682016477b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert given rvalue into BoundedVector before specified iterator.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#aba1e2a9a9ed77690aaefa4682016477b">More...</a><br /></td></tr>
<tr class="separator:aba1e2a9a9ed77690aaefa4682016477b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1377af7980ee09160895976458ad90e"><td class="memItemLeft" align="right" valign="top">_Base::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#ae1377af7980ee09160895976458ad90e">insert</a> (typename _Base::const_iterator __position, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; typename _Base::value_type &gt; __l)</td></tr>
<tr class="memdesc:ae1377af7980ee09160895976458ad90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an initializer_list into the BoundedVector.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#ae1377af7980ee09160895976458ad90e">More...</a><br /></td></tr>
<tr class="separator:ae1377af7980ee09160895976458ad90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67974af239103e098b217e438167b13a"><td class="memItemLeft" align="right" valign="top">_Base::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a67974af239103e098b217e438167b13a">insert</a> (typename _Base::const_iterator __position, typename _Base::size_type __n, const typename _Base::value_type &amp;__x)</td></tr>
<tr class="memdesc:a67974af239103e098b217e438167b13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a number of copies of given data into the BoundedVector.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a67974af239103e098b217e438167b13a">More...</a><br /></td></tr>
<tr class="separator:a67974af239103e098b217e438167b13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98851103142c5c3ddd25220bd35eaad7"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:a98851103142c5c3ddd25220bd35eaad7"><td class="memTemplItemLeft" align="right" valign="top">_Base::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a98851103142c5c3ddd25220bd35eaad7">insert</a> (typename _Base::const_iterator __position, _InputIterator __first, _InputIterator __last)</td></tr>
<tr class="memdesc:a98851103142c5c3ddd25220bd35eaad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a range into the BoundedVector.  <a href="classrosidl__runtime__cpp_1_1BoundedVector.html#a98851103142c5c3ddd25220bd35eaad7">More...</a><br /></td></tr>
<tr class="separator:a98851103142c5c3ddd25220bd35eaad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e8f2d175c16626b8f7b53181869e84"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a14e8f2d175c16626b8f7b53181869e84">begin</a> (T... args)</td></tr>
<tr class="separator:a14e8f2d175c16626b8f7b53181869e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6bd27b48c751a5e89e0668ac3eb02a"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#afb6bd27b48c751a5e89e0668ac3eb02a">end</a> (T... args)</td></tr>
<tr class="separator:afb6bd27b48c751a5e89e0668ac3eb02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a194ec1357ce59783e86b83dce1717"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a04a194ec1357ce59783e86b83dce1717">rbegin</a> (T... args)</td></tr>
<tr class="separator:a04a194ec1357ce59783e86b83dce1717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c96e076b274af1b741fd9ce2ac5c195"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a9c96e076b274af1b741fd9ce2ac5c195">rend</a> (T... args)</td></tr>
<tr class="separator:a9c96e076b274af1b741fd9ce2ac5c195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba5d999ac2845947393d26283187ee7"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a4ba5d999ac2845947393d26283187ee7">cbegin</a> (T... args)</td></tr>
<tr class="separator:a4ba5d999ac2845947393d26283187ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd0e50811872f1a65c0d76e658b0ff3"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a8dd0e50811872f1a65c0d76e658b0ff3">cend</a> (T... args)</td></tr>
<tr class="separator:a8dd0e50811872f1a65c0d76e658b0ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0553a9ef1ca894fa3d85a8f04f1dbacd"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a0553a9ef1ca894fa3d85a8f04f1dbacd">crbegin</a> (T... args)</td></tr>
<tr class="separator:a0553a9ef1ca894fa3d85a8f04f1dbacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064c6d2fbdd17b27574046a752c30c4d"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a064c6d2fbdd17b27574046a752c30c4d">crend</a> (T... args)</td></tr>
<tr class="separator:a064c6d2fbdd17b27574046a752c30c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0e76f395798203bbb2782c93d7af4a"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a3b0e76f395798203bbb2782c93d7af4a">size</a> (T... args)</td></tr>
<tr class="separator:a3b0e76f395798203bbb2782c93d7af4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3261d5c883854f7e35855fe0d1fe8eaf"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a3261d5c883854f7e35855fe0d1fe8eaf">shrink_to_fit</a> (T... args)</td></tr>
<tr class="separator:a3261d5c883854f7e35855fe0d1fe8eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c29aac53279ec8610284fade71d6a2"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a14c29aac53279ec8610284fade71d6a2">capacity</a> (T... args)</td></tr>
<tr class="separator:a14c29aac53279ec8610284fade71d6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cafefaa48c3676ac9c161fa9ea61834"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a4cafefaa48c3676ac9c161fa9ea61834">empty</a> (T... args)</td></tr>
<tr class="separator:a4cafefaa48c3676ac9c161fa9ea61834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bfdae866d3ba31330c9c72221a32c9"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#ad9bfdae866d3ba31330c9c72221a32c9">at</a> (T... args)</td></tr>
<tr class="separator:ad9bfdae866d3ba31330c9c72221a32c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662637ebbbe02726abf936c26463a491"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a662637ebbbe02726abf936c26463a491">front</a> (T... args)</td></tr>
<tr class="separator:a662637ebbbe02726abf936c26463a491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fedc1c55807d10373890b936506f198"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a4fedc1c55807d10373890b936506f198">back</a> (T... args)</td></tr>
<tr class="separator:a4fedc1c55807d10373890b936506f198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a0b5b15a24542d3385f0a7f9a83dd7"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a48a0b5b15a24542d3385f0a7f9a83dd7">erase</a> (T... args)</td></tr>
<tr class="separator:a48a0b5b15a24542d3385f0a7f9a83dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2a11c70415cbc183f87c231ef07d49"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a9e2a11c70415cbc183f87c231ef07d49">pop_back</a> (T... args)</td></tr>
<tr class="separator:a9e2a11c70415cbc183f87c231ef07d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c8492c8d8d7a436f6592799046963c"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#ad4c8492c8d8d7a436f6592799046963c">clear</a> (T... args)</td></tr>
<tr class="separator:ad4c8492c8d8d7a436f6592799046963c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_vector"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_vector')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el"  href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt; _Tp, std::allocator&lt; _Tp &gt; &gt;</a></td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/push_back.html">push_back</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/rbegin.html">crbegin</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/erase.html">erase</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/data.html">data</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/insert.html">insert</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/pop_back.html">pop_back</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/shrink_to_fit.html">shrink_to_fit</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/back.html">back</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/end.html">end</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/resize.html">resize</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/emplace_back.html">emplace_back</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/size.html">size</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/begin.html">cbegin</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/front.html">front</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/~vector.html">~vector</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/rbegin.html">rbegin</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/rend.html">crend</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/assign.html">assign</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/operator=.html">operator=</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/vector.html">vector</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/reserve.html">reserve</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/capacity.html">capacity</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/empty.html">empty</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/end.html">cend</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/swap.html">swap</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/max_size.html">max_size</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/rend.html">rend</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/get_allocator.html">get_allocator</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/clear.html">clear</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/at.html">at</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/emplace.html">emplace</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/operator_at.html">operator[]</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem: inherit pro_methods_vector"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/begin.html">begin</a> (T... args)</td></tr>
<tr class="separator: inherit pro_methods_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _Tp, std::size_t _UpperBound, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;<br />
class rosidl_runtime_cpp::BoundedVector&lt; _Tp, _UpperBound, _Alloc &gt;</h3>

<p>A container based on <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> but with an upper bound. </p>
<p>Meets the same requirements as <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Tp</td><td>Type of element </td></tr>
    <tr><td class="paramname">_UpperBound</td><td>The upper bound for the number of elements </td></tr>
    <tr><td class="paramname">_Alloc</td><td>Allocator type, defaults to std::allocator&lt;_Tp&gt; </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9b67ad1735b252821d65f89d4c372f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b67ad1735b252821d65f89d4c372f97">&#9670;&nbsp;</a></span>BoundedVector() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a BoundedVector with no elements. </p>

</div>
</div>
<a id="a4be47de071b773e16ee109babafed265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be47de071b773e16ee109babafed265">&#9670;&nbsp;</a></span>BoundedVector() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> </td>
          <td>(</td>
          <td class="paramtype">const typename _Base::allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a BoundedVector with no elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>An allocator object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a784bc45020945077a0f29b3fd66b330d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784bc45020945077a0f29b3fd66b330d">&#9670;&nbsp;</a></span>BoundedVector() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> </td>
          <td>(</td>
          <td class="paramtype">typename _Base::size_type&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename _Base::allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a BoundedVector with default constructed elements. </p>
<p>This constructor fills the BoundedVector with <em>__n</em> default constructed elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The number of elements to initially create </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebcbcc89a4e79e70bf937a526009c97c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebcbcc89a4e79e70bf937a526009c97c">&#9670;&nbsp;</a></span>BoundedVector() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> </td>
          <td>(</td>
          <td class="paramtype">typename _Base::size_type&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename _Base::value_type &amp;&#160;</td>
          <td class="paramname"><em>__value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename _Base::allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a BoundedVector with copies of an exemplar element. </p>
<p>This constructor fills the BoundedVector with <em>__n</em> copies of <em>__value</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The number of elements to initially create </td></tr>
    <tr><td class="paramname">__value</td><td>An element to copy </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba011bc822a8c2f3bed700d7aba8bd1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba011bc822a8c2f3bed700d7aba8bd1d">&#9670;&nbsp;</a></span>BoundedVector() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>BoundedVector copy constructor. </p>
<p>The newly-created BoundedVector uses a copy of the allocation object used by <em>__x</em>. All the elements of <em>__x</em> are copied, but any extra memory in <em>__x</em> (for fast expansion) will not be copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A BoundedVector of identical element and allocator types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a759dc2faee77bdc3271e9ee591773cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759dc2faee77bdc3271e9ee591773cd0">&#9670;&nbsp;</a></span>BoundedVector() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>BoundedVector move constructor. </p>
<p>The newly-created BoundedVector contains the exact contents of <em>__x</em>. The contents of <em>__x</em> are a valid, but unspecified BoundedVector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A BoundedVector of identical element and allocator types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac34c1b3d2998a2f16004e03975dd506d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34c1b3d2998a2f16004e03975dd506d">&#9670;&nbsp;</a></span>BoundedVector() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename _Base::allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor with alternative allocator. </p>

</div>
</div>
<a id="adca3e7ac66889d3996809f0b416e05a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca3e7ac66889d3996809f0b416e05a1">&#9670;&nbsp;</a></span>BoundedVector() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; typename _Base::value_type &gt;&#160;</td>
          <td class="paramname"><em>__l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename _Base::allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code>typename&#160;_Base::allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a BoundedVector from an initializer list. </p>
<p>Create a BoundedVector consisting of copies of the elements in the initializer_list <em>__l</em>.</p>
<p>This will call the element type's copy constructor N times (where N is <em>__l.size()</em>) and do no memory reallocation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>An initializer_list </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af31cd9a81afab23406e52c168311c2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31cd9a81afab23406e52c168311c2d8">&#9670;&nbsp;</a></span>BoundedVector() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename _Base::allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a BoundedVector from a range. </p>
<p>Create a BoundedVector consisting of copies of the elements from [first,last).</p>
<p>If the iterators are forward, bidirectional, or random-access, then this will call the elements' copy constructor N times (where N is distance(first,last)) and do no memory reallocation. But if only input iterators are used, then this will do at most 2N calls to the copy constructor, and logN memory reallocations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48dc3c168ebba1ebc13303ef42de3af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48dc3c168ebba1ebc13303ef42de3af0">&#9670;&nbsp;</a></span>~BoundedVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::~<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The dtor only erases the elements. </p>
<p>Note that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a98049e1dc6a05b67825299042fad574b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98049e1dc6a05b67825299042fad574b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&amp; <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>BoundedVector assignment operator. </p>
<p>All the elements of <em>__x</em> are copied, but any extra memory in <em>__x</em> (for fast expansion) will not be copied. Unlike the copy constructor, the allocator object is not copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A BoundedVector of identical element and allocator types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afcf20ca748fc8deab90c8a9a3909752c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf20ca748fc8deab90c8a9a3909752c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&amp; <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>BoundedVector move assignment operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A BoundedVector of identical element and allocator types. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bde3d73393fa3c772aa751c4fc0d295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bde3d73393fa3c772aa751c4fc0d295">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">BoundedVector</a>&amp; <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; typename _Base::value_type &gt;&#160;</td>
          <td class="paramname"><em>__l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>BoundedVector list assignment operator. </p>
<p>This function fills a BoundedVector with copies of the elements in the initializer list <em>__l</em>.</p>
<p>Note that the assignment completely changes the BoundedVector and that the resulting BoundedVector's size is the same as the number of elements assigned. Old data may be lost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>An initializer_list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a257767f64c94837e25c2bbd598e63965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257767f64c94837e25c2bbd598e63965">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">typename _Base::size_type&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename _Base::value_type &amp;&#160;</td>
          <td class="paramname"><em>__val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a given value to a BoundedVector. </p>
<p>This function fills a BoundedVector with <em>__n</em> copies of the given value. Note that the assignment completely changes the BoundedVector and that the resulting BoundedVector's size is the same as the number of elements assigned. Old data may be lost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>Number of elements to be assigned </td></tr>
    <tr><td class="paramname">__val</td><td>Value to be assigned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ba629d7e4559e6f4e14432c6520a597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba629d7e4559e6f4e14432c6520a597">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a range to a BoundedVector. </p>
<p>This function fills a BoundedVector with copies of the elements in the range [__first,__last).</p>
<p>Note that the assignment completely changes the BoundedVector and that the resulting BoundedVector's size is the same as the number of elements assigned. Old data may be lost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a397c503fdf0733eb320d54719ca2094f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397c503fdf0733eb320d54719ca2094f">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; typename _Base::value_type &gt;&#160;</td>
          <td class="paramname"><em>__l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign an initializer list to a BoundedVector. </p>
<p>This function fills a BoundedVector with copies of the elements in the initializer list <em>__l</em>.</p>
<p>Note that the assignment completely changes the BoundedVector and that the resulting BoundedVector's size is the same as the number of elements assigned. Old data may be lost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>An initializer_list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42d31ed11b31f083236a5ccd35060a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d31ed11b31f083236a5ccd35060a78">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_Base::size_type <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/size.html">size()</a> of the largest possible BoundedVector. <br  />
 </p>

</div>
</div>
<a id="a8b11bd88990945e988619ae4c946fd12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b11bd88990945e988619ae4c946fd12">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">typename _Base::size_type&#160;</td>
          <td class="paramname"><em>__new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the BoundedVector to the specified number of elements. </p>
<p>This function will resize the BoundedVector to the specified number of elements. If the number is smaller than the BoundedVector's current size the BoundedVector is truncated, otherwise default constructed elements are appended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__new_size</td><td>Number of elements the BoundedVector should contain </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb1cec89de0cc428783817370c570052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1cec89de0cc428783817370c570052">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">typename _Base::size_type&#160;</td>
          <td class="paramname"><em>__new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename _Base::value_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the BoundedVector to the specified number of elements. </p>
<p>This function will resize the BoundedVector to the specified number of elements. If the number is smaller than the BoundedVector's current size the BoundedVector is truncated, otherwise the BoundedVector is extended and new elements are populated with given data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__new_size</td><td>Number of elements the BoundedVector should contain </td></tr>
    <tr><td class="paramname">__x</td><td>Data with which new elements should be populated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afedcdabf83ebd480bf5e407eac3b6b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afedcdabf83ebd480bf5e407eac3b6b8e">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">typename _Base::size_type&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to preallocate enough memory for specified number of elements. </p>
<p>This function attempts to reserve enough memory for the BoundedVector to hold the specified number of elements. If the number requested is more than <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a42d31ed11b31f083236a5ccd35060a78">max_size()</a>, length_error is thrown.</p>
<p>The advantage of this function is that if optimal code is a necessity and the user can determine the number of elements that will be required, the user can reserve the memory in advance, and thus prevent a possible reallocation of memory and copying of BoundedVector data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>Number of elements required </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" href="http://en.cppreference.com/w/cpp/error/length_error.html">std::length_error</a></td><td>If <em>n</em> exceeds <code><a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a42d31ed11b31f083236a5ccd35060a78">max_size()</a></code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88f40a782edaa41caed8d07dbd411999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f40a782edaa41caed8d07dbd411999">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; !std::is_same&lt; T, _Tp &gt;::value &amp;&amp;!std::is_same&lt; T, bool &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer such that [<a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a88f40a782edaa41caed8d07dbd411999" title="Return a pointer such that [data(), data() + size()) is a valid range.">data()</a>, <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a88f40a782edaa41caed8d07dbd411999" title="Return a pointer such that [data(), data() + size()) is a valid range.">data()</a> + <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/size.html">size()</a>) is a valid range. </p>
<p>For a non-empty BoundedVector, <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html#a88f40a782edaa41caed8d07dbd411999" title="Return a pointer such that [data(), data() + size()) is a valid range.">data()</a> == &amp;<a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/front.html">front()</a>. </p>

</div>
</div>
<a id="a6751d4a9bf8a3163d06185d5f25d01e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6751d4a9bf8a3163d06185d5f25d01e8">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; !std::is_same&lt; T, _Tp &gt;::value &amp;&amp;!std::is_same&lt; T, bool &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f804dbbbd70111c2e9d0e4cf5f4f1d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f804dbbbd70111c2e9d0e4cf5f4f1d2">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const typename _Base::value_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add data to the end of the BoundedVector. </p>
<p>This is a typical stack operation. The function creates an element at the end of the BoundedVector and assigns the given data to it. Due to the nature of a BoundedVector this operation can be done in constant time if the BoundedVector has preallocated space available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Data to be added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66251403754048dbc0eb5dc33a32b448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66251403754048dbc0eb5dc33a32b448">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">typename _Base::value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6e716dd4d1adbe8d7f5cc8d9bb67a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e716dd4d1adbe8d7f5cc8d9bb67a36">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add data to the end of the BoundedVector. </p>
<p>This is a typical stack operation. The function creates an element at the end of the BoundedVector and assigns the given data to it. Due to the nature of a BoundedVector this operation can be done in constant time if the BoundedVector has preallocated space available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments to be forwarded to the constructor of _Tp </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e46aa51d1fa2950966bf362dc5d81d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e46aa51d1fa2950966bf362dc5d81d9">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_Base::iterator <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">typename _Base::const_iterator&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an object in BoundedVector before specified iterator. </p>
<p>This function will insert an object of type T constructed with T(std::forward&lt;Args&gt;(args)...) before the specified location. Note that this kind of operation could be expensive for a BoundedVector and if it is frequently used the user should consider using <a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>A const_iterator into the BoundedVector </td></tr>
    <tr><td class="paramname">__args</td><td>Arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data </dd></dl>

</div>
</div>
<a id="aa245ce96b6f037bcef941586f6b1ce79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa245ce96b6f037bcef941586f6b1ce79">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_Base::iterator <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">typename _Base::const_iterator&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename _Base::value_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert given value into BoundedVector before specified iterator. </p>
<p>This function will insert a copy of the given value before the specified location. Note that this kind of operation could be expensive for a BoundedVector and if it is frequently used the user should consider using <a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>A const_iterator into the BoundedVector </td></tr>
    <tr><td class="paramname">__x</td><td>Data to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data </dd></dl>

</div>
</div>
<a id="aba1e2a9a9ed77690aaefa4682016477b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba1e2a9a9ed77690aaefa4682016477b">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_Base::iterator <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">typename _Base::const_iterator&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename _Base::value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert given rvalue into BoundedVector before specified iterator. </p>
<p>This function will insert a copy of the given rvalue before the specified location. Note that this kind of operation could be expensive for a BoundedVector and if it is frequently used the user should consider using <a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>A const_iterator into the BoundedVector </td></tr>
    <tr><td class="paramname">__x</td><td>Data to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data </dd></dl>

</div>
</div>
<a id="ae1377af7980ee09160895976458ad90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1377af7980ee09160895976458ad90e">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_Base::iterator <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">typename _Base::const_iterator&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; typename _Base::value_type &gt;&#160;</td>
          <td class="paramname"><em>__l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an initializer_list into the BoundedVector. </p>
<p>This function will insert copies of the data in the initializer_list <em>l</em> into the BoundedVector before the location specified by <em>position</em>.</p>
<p>Note that this kind of operation could be expensive for a BoundedVector and if it is frequently used the user should consider using <a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>An iterator into the BoundedVector </td></tr>
    <tr><td class="paramname">__l</td><td>An initializer_list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67974af239103e098b217e438167b13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67974af239103e098b217e438167b13a">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_Base::iterator <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">typename _Base::const_iterator&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename _Base::size_type&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename _Base::value_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a number of copies of given data into the BoundedVector. </p>
<p>This function will insert a specified number of copies of the given data before the location specified by <em>position</em>.</p>
<p>Note that this kind of operation could be expensive for a BoundedVector and if it is frequently used the user should consider using <a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>A const_iterator into the BoundedVector </td></tr>
    <tr><td class="paramname">__n</td><td>Number of elements to be inserted </td></tr>
    <tr><td class="paramname">__x</td><td>Data to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data </dd></dl>

</div>
</div>
<a id="a98851103142c5c3ddd25220bd35eaad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98851103142c5c3ddd25220bd35eaad7">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_Base::iterator <a class="el" href="classrosidl__runtime__cpp_1_1BoundedVector.html">rosidl_runtime_cpp::BoundedVector</a>&lt; _Tp, _UpperBound, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">typename _Base::const_iterator&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a range into the BoundedVector. </p>
<p>This function will insert copies of the data in the range [__first,__last) into the BoundedVector before the location specified by <em>pos</em>.</p>
<p>Note that this kind of operation could be expensive for a BoundedVector and if it is frequently used the user should consider using <a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>A const_iterator into the BoundedVector </td></tr>
    <tr><td class="paramname">__first</td><td>An input iterator </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data </dd></dl>

</div>
</div>
<a id="a14e8f2d175c16626b8f7b53181869e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e8f2d175c16626b8f7b53181869e84">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb6bd27b48c751a5e89e0668ac3eb02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6bd27b48c751a5e89e0668ac3eb02a">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::end</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04a194ec1357ce59783e86b83dce1717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a194ec1357ce59783e86b83dce1717">&#9670;&nbsp;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::rbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c96e076b274af1b741fd9ce2ac5c195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c96e076b274af1b741fd9ce2ac5c195">&#9670;&nbsp;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::rend</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ba5d999ac2845947393d26283187ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba5d999ac2845947393d26283187ee7">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::cbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8dd0e50811872f1a65c0d76e658b0ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd0e50811872f1a65c0d76e658b0ff3">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::cend</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0553a9ef1ca894fa3d85a8f04f1dbacd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0553a9ef1ca894fa3d85a8f04f1dbacd">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::crbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a064c6d2fbdd17b27574046a752c30c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064c6d2fbdd17b27574046a752c30c4d">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::crend</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b0e76f395798203bbb2782c93d7af4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0e76f395798203bbb2782c93d7af4a">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::size</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3261d5c883854f7e35855fe0d1fe8eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3261d5c883854f7e35855fe0d1fe8eaf">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::shrink_to_fit</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a14c29aac53279ec8610284fade71d6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c29aac53279ec8610284fade71d6a2">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::capacity</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4cafefaa48c3676ac9c161fa9ea61834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cafefaa48c3676ac9c161fa9ea61834">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::empty</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9bfdae866d3ba31330c9c72221a32c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9bfdae866d3ba31330c9c72221a32c9">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::at</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a662637ebbbe02726abf936c26463a491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662637ebbbe02726abf936c26463a491">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::front</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fedc1c55807d10373890b936506f198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fedc1c55807d10373890b936506f198">&#9670;&nbsp;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::back</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48a0b5b15a24542d3385f0a7f9a83dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a0b5b15a24542d3385f0a7f9a83dd7">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::erase</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e2a11c70415cbc183f87c231ef07d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2a11c70415cbc183f87c231ef07d49">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::pop_back</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4c8492c8d8d7a436f6592799046963c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c8492c8d8d7a436f6592799046963c">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _UpperBound, typename _Alloc  = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T std::vector::clear</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/rosidl_runtime_cpp/<a class="el" href="bounded__vector_8hpp_source.html">bounded_vector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
